https://dzone.com/articles/java-evolution-changed-developer-workflow

==========================================================================! Modern Java Features (Java 9–25) – Summary Overview !======================================================================
Since Java 8, the language has undergone a remarkable transformation, introducing a wide range of features that focus on developer productivity, performance optimization, readability, and modern programming paradigms.
This document captures the evolution of Java from version 9 to 25, providing an in-depth explanation, code examples, and practical use cases for every key enhancement. Each feature is discussed in the context of why it was introduced, how it simplifies development, and where it fits in real-world enterprise applications.
From module systems and var keyword to pattern matching, sealed classes, records, switch expressions, and virtual threads, the modern Java ecosystem is now faster, cleaner, and more aligned with functional and reactive programming needs.
This documentation aims to serve as a comprehensive learning and reference guide for developers transitioning from legacy Java (≤8) to Modern Java (9–25) — helping you master the syntax, internal behavior, and design philosophy behind each update.
Key Highlights:
=> Language Enhancements : var, Records, Sealed Classes, Pattern Matching, Text Blocks, Switch Expressions
  → Description: Simplify syntax, improve readability, and support modern programming paradigms.

=> Performance & Concurrency : Virtual Threads, Scoped Values, Structured Concurrency
  → Description: Boost scalability, simplify thread management, and enhance concurrency performance in multi-threaded applications.

=> API Improvements : Stream API Enhancements, Collection Factory Methods, Optional API Updates
  → Description: Introduce concise and expressive APIs for better data processing and cleaner code.

=> JVM & JIT Innovations : Graal JIT Compiler, ZGC, Shenandoah GC, Class Data Sharing (CDS) Improvements
  → Description: Optimize runtime performance, reduce latency, and minimize memory footprint.

=> Project Amber Features : Pattern Matching, Records, Enhanced Switch Expressions
  → Description: Deliver compact and safer data modeling with modern language constructs.

=> Project Loom : Virtual Threads, Structured Concurrency
  → Description: Revolutionize Java concurrency by making millions of lightweight threads possible.

=> Project Panama : Foreign Function & Memory API
  → Description: Enable seamless interaction between Java and native (C/C++) code with better performance.

=> Project Valhalla : Value Objects (Preview)
  → Description: Introduce value-based data types for high-performance computation without object identity overhead.

=> Modularity (Java 9) : Java Platform Module System (JPMS)
  → Description: Improve encapsulation, maintainability, and startup efficiency for large-scale applications.

======================================================================================! Java 10-11 !====================================================================================

=> Local Variable Type: var
  -> Explicit Typing: In explicit typing, the programmer specifies the data type of a variable at the time of its declaration.
  -> Inferred Typing: In inferred typing, the programming language determines the data type of a variable based on the value assigned to it.
  -> Update: In JDK 10 and later, you can declare local variables with non-null initializers with the var identifier(var is a reserved type name, not a keyword), which can help you write code that’s easier to read.
    -> var data = null; // ❌ Compilation Error: Cannot infer type for local variable initialized to 'null'
  -> USECASE:
    -> Local variable with initializer: In traditional Java, you must explicitly declare the type of a variable. Using var, the compiler infers the type from the initializer, making the code cleaner.
        -> Code Example: https://github.com/Vinay8386/core_Java/blob/main/Java10_11/TypeInferenceExample.java
    -> Enhance For-Loops: In for-each loops, var can simplify type declaration. In traditional, you can also use var for the index variable.
        -> Code Example: https://github.com/Vinay8386/core_Java/blob/main/Java10_11/ForEachWithVarExample.java
    -> Try-With-Resources: Try-With-Resources automatically closes resources (like files, streams) after use, eliminating the need for explicit finally blocks. Java 10 allows using 'var' inside the try-with-resources declaration, making the code more concise while still strongly typed.
        -> Code Example: https://github.com/Vinay8386/core_Java/blob/main/Java10_11/TryWithResourcesExample.java
    -> Lambda Expressions: Starting with JDK 11, var can be used for parameters in lambda expression. This ensures consistency between lambda parameters and local variable declarations. In other words, just as local variables can use var for the compiler to infer their type, lambda parameters can also use var to let the compiler deduce their type based on context.
        -> Code Example: https://github.com/Vinay8386/core_Java/blob/main/Java10_11/LambdaVarExample.java
    
  -> Guidelines and Restrictions: 
    -> Consistency: You cannot mix var and explicitly typed parameters or inferred types in lambda expressions:
    -> Readability: While var simplifies code, excessive use can make code harder to understand if the inferred type isn't immediately clear.
    -> Avoid Ambiguity: Use var only when the initializer provides enough context to understand the type

=> .repeat(n): This is a new method introduced in Java 11 and is very handy for repeating strings without loops.
  -> Method Signature: "public String repeat(int count)"
    -> count → the number of times the string should be repeated.
    -> Returns → a new string consisting of the original string repeated count times.
    -> Code Example: https://github.com/Vinay8386/core_Java/blob/main/Java10_11/StringRepeatExample.java










